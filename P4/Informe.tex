\documentclass[a4paper]{article}

\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{titling}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[toc,page]{appendix}
\geometry{a4paper, margin=7em}


\lstset{
    frame=single,
    breaklines=true,
    numbers=left,
    keywordstyle=\color{blue},
    numbersep=15pt,
    numberstyle=,
    basicstyle=\linespread{1.5}\selectfont\ttfamily,
    commentstyle=\color{gray},
    stringstyle=\color{orange},
    identifierstyle=\color{green!40!black},
}

\setlength{\parindent}{4em}
%%\setlength{\parindent}{0em}
\setlength{\parskip}{0.8em}
    
%%\renewcommand{\familydefault}{phv} %%Seleccionamos Helvetica
    
\lstdefinestyle{console}
{
    numbers=left,
    backgroundcolor=\color{violet},
    %%belowcaptionskip=1\baselineskip,
    breaklines=true,
    %%xleftmargin=\parindent,
    %%showstringspaces=false,
    basicstyle=\footnotesize\ttfamily,
    %%keywordstyle=\bfseries\color{green!40!black},
    %%commentstyle=\itshape\color{green},
    %%identifierstyle=\color{blue},
    %%stringstyle=\color{orange},
    basicstyle=\scriptsize\color{white}\ttfamily,
}
    
\title{Sincronización de procesos con mutexes}
\author{Aldán Creo Mariño}
    
    
\pagestyle{fancy}
\fancyfoot[R]{\thepage}
\fancyfoot[C]{}
\makeatletter
\let\runauthor\@author
\let\runtitle\@title
\makeatother
\fancyhead[L]{\runauthor}
\fancyhead[C]{SOI}
\fancyhead[R]{Práctica 4}
    
\begin{document}
\maketitle

\section{Apartado 1} \label{apartado_1}

\subsection{Comentarios previos}

En esta práctica, lo que se nos pide es que resolvamos el problema del productor-consumidor utilizando mutexes y variables de condición.

Explicándolo de forma breve, los mutexes sirven para bloquear el acceso a un recurso (la región crítica del código del programa), para un solo hilo, para que sólo él pueda estar en esa región a la vez. De esta forma se evitan carreras críticas. Las variables de condición, por su parte, sirven para hacer que un hilo espere a otro, cuando se encuentra dentro de una región crítica y requiere de la intervención de otro hilo (nuestro caso, por ejemplo, cuando un consumidor no tiene elementos para consumir). De esta forma, libera el mutex y se bloquea inmediatamente en base a una variable de condición. Otro hilo lo despertará eventualmente enviando una señal a dicha variable de condicion (\texttt{pthread\_cond\_signal()}). Las funciones que manejan los mutexes y las variables de condición se encuentran definidas en \texttt{pthread.h}.

\subsection{Desarrollo del código}

Para desarrollar el código de este apartado, me he basado en la plantilla que se incluye en la presentación de la asignatura. No aporto novedades importantes al respecto, así que no creo que sea pertinente que entre a comentar el código. Básicamente, se trata de la implementación del problema del productor-consumidor usando mutexes y variables de condición como mecanismo de exclusión mutua y sincronización.

He creado un mismo archivo (\texttt{1.c}), que contiene los códigos del productor y del consumidor. Desde el \texttt{main} creo los hilos de productores y consumidores. El código se parece mucho al que entregué en el apartado voluntario de la práctica anterior, ya que también se nos pedía resolver este problema recurriendo a hilos.

\subsection{Ejecución}

El código lo he compilado con \texttt{gcc -O0 -lrt -lpthread}. En una instancia de un shell, ejecuté el programa, ya que desde el mismo hilo se crean todos los productores y todos los consumidores.

\subsection{Desarrollo del código}

El desarrollo del código ha sido bastante directo, ya que me basé en lo que ya había desarrollado en la práctica anterior. El uso de los mutexes y las variables de condición es muy sencillo, ya que llega con inicializarlos al principio del programa, en el hilo principal. Después, este hilo crea los consumidores y productores, y cuando todos acaban, se encarga de cerrar los mutexes y las variables de condición. El código base, además, se encuentra en las diapositivas del tema 1, como comenté. Por eso el desarrollo del código fue bastante rápido y sencillo.

He puesto especial atención a las ideas que se destacan de forma enumerada en el guion de la práctica, pero no entraré a comentarlas por brevedad, ya que están recogidas allí. Los parámetros del código se pueden cambiar fácilmente, ya que aparecen arriba del programa, como \texttt{define}s.

Para implementar la cola me he servido de dos variables compartidas por todos los hilos, \texttt{cuenta}, y \texttt{primero}. En base a esos dos parámetros puedo calcular quién es el último de la cola (\texttt{(primero + cuenta) \% N}). He modificado las funciones que tenía para insertar y sacar elementos del buffer, para que ahora lo traten como una cola. El cambio no afecta a más partes del código.

Un ejemplo recortado de ejecución sería:

\begin{lstlisting}[language=]
    Generado el productor 0
    Generado el productor 1
    Generado el productor 2
    Generado el productor 3
    Generado el productor 4
    (C) Adquiero el mutex
    (P) Inserto: 36
            -------------------------------
            | 36  | 0   | 0   | 0   | 0   |
            -------------------------------
    
    (C) Libero el mutex
    Generado el consumidor 0
    Generado el consumidor 1
    (C) Adquiero el mutex
    (P) Inserto: 882
            -------------------------------
            | 36  | 882 | 0   | 0   | 0   |
            -------------------------------
    
    (C) Libero el mutex
    Generado el consumidor 2
    (C) Adquiero el mutex
    (C) Saco: 36
            -------------------------------
            | 0   | 882 | 0   | 0   | 0   |
            -------------------------------
    
    (C) Libero el mutex
    Generado el consumidor 3
    (C) Adquiero el mutex
    (C) Saco: 882
            -------------------------------
            | 0   | 0   | 0   | 0   | 0   |
            -------------------------------
    
    (C) Libero el mutex
    (C) Adquiero el mutex
    (C) Adquiero el mutex
    (C) Adquiero el mutex
    (P) Inserto: 761
            -------------------------------
            | 0   | 0   | 761 | 0   | 0   |
            -------------------------------
    
    (C) Libero el mutex
    (C) Saco: 761
            -------------------------------
            | 0   | 0   | 0   | 0   | 0   |
            -------------------------------
    
    (C) Libero el mutex
\end{lstlisting}

En esta salida, puede verse claramente cómo la cola se va vaciando y llenando. No se aprecian carreras críticas, ya que lógicamente, el acceso a la cola está controlado por el mutex.

La cola se va llenando y vaciando a saltos, porque todos los productores y consumidores tienen \texttt{sleeps} artificiales a la hora de producir o consumir. Esto lo que provoca es que el acceso a la cola para insertar o sacar elementos sea casi instantáneo, por lo que la región crítica es bastante reducida en el tiempo en el que se está en ella, pero lo que no es instantáneo es producir elementos o consumirlos, por lo que llega un punto en el programa en el que todos los hilos están ocupados produciendo o consumiendo, y nadie está dentro de la región crítica. Por esto se aprecian una especie de ``saltos'' a la hora de ejecutar el programa.

Es destacable el caso en el que aparecen tres ``(C) Adquiero el mutex'' seguidos. En este caso, no es que esté fallando el mecanismo de exclusión mutua, sino que lo que ocurre es que el buffer está vacío, por lo que no hay nada que consumir, así que los consumidores liberan el mutex para que llegue un productor eventualmente e introduzca algo en el buffer. Es decir, liberan el mutex y quedan a la espera sobre una variable de condición. En el ejemplo de ejecución que vemos arriba, entran nuevos consumidores a la región crítica, que también pasan a esperar sobre esa variable. Por eso vemos el mensaje repetido, no porque falle la exclusión mutua. De hecho, los mensajes dejan de repetirse cuando entra un productor. Esta explicación es análoga para el caso en el que el buffer esté lleno, y los productores queden a la espera de que llegue algún consumidor.

\section{Apartado 2}

Este apartado consiste en resolver el problema con mutexes, pero sin variables de condición. Interpreto que se pueden usar otros mecanismos aparte de los mutexes.

En el guion de la práctica se indica que solo hay que comentar el primer apartado, así que no destacaré nada sobre este. El código está en el anexo \ref{anexo2}.

En el propio código, al principio, he incluido un breve comentario explicativo.

\section{Comentarios adicionales}

Pese a que los códigos aparecen recogidos en los anexos, he decidido incluírlos también como archivos separados en la entrega.
    
\begin{appendices} 
\section{\LARGE \textbf{Anexo 1}}\label{anexo1}
\lstinputlisting[language=C]{1.c}
    
\section{\LARGE \textbf{Anexo 2}}\label{anexo2}
\lstinputlisting[language=C]{2.c}
    
\end{appendices}

\end{document}